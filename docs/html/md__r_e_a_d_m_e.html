<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>counter: counter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">counter
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Code exercise implemented by John D. Hopkins</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">counter </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>C++ code exercise for counting and displaying token frequencies in given files.</p>
<h3>Implementation Notes</h3>
<p>This exercise was implemented using C++11. An Xcode project unifies things, but the source files can be put into any other IDE supporting C++11. The counter Xcode target will build and run a counter executable. The Unit Test target, not surprisingly, runs the unit tests.</p>
<p>A few extras were added beyond what is mentioned in the original documentation below. They help to make the implementation a better example of modern software development.</p>
<p>First, the exercise was built using test-driven development (see "Unit Tests/counter_test.cpp). The Boost Unit Test Framework was used. This is freely available and popular with many C++ developers. It only affects the above mentioned file. No Boost libraries were used in the actual implementation code.</p>
<p>Second, some extra class methods (and non-class methods) were added to make the classes "smart" to work with. This includes move constructors, move assignment operators, and swap for most of the classes. Copy constructors and copy assignment operators were deleted because file streams can't be copied. These extras were not added to the Counter class because it is a Singleton (Design Pattern) managing the other classes.</p>
<p>Third, concurrency programming was added to handle the tokenization of multiple files at the same time. Concurrency is only invoked after a file number threshold is reached and is expressed as a <code>static const int</code> in the Counter class. Currently that threshold is set to 2 for this exercise, but could be increased upon further performance testing. Threads and how many to use are handled via the C++11 <code>async</code> function.</p>
<p>In addition to using concurrency to improve performance, other items specific to C++11 were used. This included using the hash-based unordered_map, with constant-time lookup and insertion; inserting items into containers using <code>emplace</code> and <code>emplace_back</code>; as well as the use of move assignment and construction throughout. Though not specific to C++11, the <code>std::list</code> container was chosen over <code>std::vector</code> because <code>std::list</code> favors speedy element addition without needing to know the amount of elements ahead of time.</p>
<p>Note further that the implementation widely uses the RAII principle (Resource Acquisition Is Initialization) as encouraged by Bjarne Stroustrup, the maker of the C++ language. All new/delete's and file open/close's are hidden in constructor/destructor methods respectively.</p>
<p>The Single Responsibility Principle of the SOLID software development principles was also followed. For example, string utility functions were separated out into their own file (<code><a class="el" href="_string__utils_8hpp.html">String_utils.hpp</a>/cpp</code>), instead of included in the <code>File_token_counter</code> class. These functions are tested indirectly through the output of other classes of this exercise.</p>
<h3>Original Exercise Documentation</h3>
<p>Using C++, write a program to do the following:</p>
<ol type="1">
<li>Open a file specified as the first parameter on the command-line that contains a list of filenames, one filename per line.</li>
<li>For each filename in the list, read each file and tokenize the contents. a. Tokenizing for this problem is defined as separating the file into words (characters delimited by whitespace), stripping leading and trailing punctuation, and forcing the token to be lowercase.</li>
<li>Output a file specified by the second parameter on the command line containing a list of total unique tokens and their count, each on a separate line, sorted by frequency.</li>
</ol>
<p>For instance, if the first file (input.txt) contained a single line:</p>
<p>test.txt</p>
<p>And that file contained the text: </p><div class="fragment"><div class="line">This is only a test. A *very* short test!</div></div><!-- fragment --><p>Running the program: </p><div class="fragment"><div class="line">&gt; ./counter input.txt output.txt</div></div><!-- fragment --><p>Would result in an output file (output.txt) that looks like: </p><div class="fragment"><div class="line">a 2</div><div class="line">test 2</div><div class="line">is 1</div><div class="line">only 1</div><div class="line">short 1</div><div class="line">this 1</div><div class="line">very 1</div></div><!-- fragment --><p>You can use STL, but avoid usage of third-party libraries. Note that although the above example is frequency and alphabetically sorted, only frequency sorting is required. For purposes of this problem, you can assume all valid input files will be UTF-8 encoded English text. Use Doxygen-style function documentation.</p>
<p>You should approach this project as you would if you worked at the company in terms of quality, style, and performance. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
